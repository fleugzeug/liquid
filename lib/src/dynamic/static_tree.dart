// Copyright (c) 2014, the Liquid project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of liquid.dynamic;

/// Static Tree VDom Node generated by static tree factory.
///
/// Static tree nodes are simple stateless nodes with lazy subtree generation.
/// Subtree is created when `render()` method is invoked and it never updates
/// later, even if the properties are changed. `update()` method just transfers
/// reference to root-level element from the previous node to the new one.
class VStaticTree extends vdom.VElementBase {
  vdom.VNode _vTree;
  Function _buildFunction;
  Map<Symbol, dynamic> _properties;

  VStaticTree(
      this._buildFunction,
      this._properties,
      Object key,
      List<vdom.VNode> children,
      String id,
      Map<String, String> attributes,
      List<String> classes,
      Map<String, String> styles)
      : super(key, children, id, attributes, classes, styles);

  void create(vdom.Context context) {
    _vTree = build();
    assert(invariant(_vTree != null,
        'build() method should return Virtual DOM Node, but instead returns '
        '`null` value.'));
    _vTree.create(context);
    ref = _vTree.ref;
  }

  void render(vdom.Context context) {
    super.render(context);
    _vTree.render(context);
  }

  vdom.VNode build() => Function.apply(_buildFunction, const [], _properties);

  void attached() { _vTree.attached(); }
  void detached() { _vTree.detached(); }
  void attach() { _vTree.attach(); }
}

/// Factory generated by [staticTreeFactory] method.
class _VStaticTreeFactory extends Function {
  /// build function that generates virtual dom.
  Function _buildFunction;

  ClosureMirror _closureMirror;
  HashMap<Symbol, Property> _propertyTypes;

  _VStaticTreeFactory(this._buildFunction) {
     _closureMirror = reflect(_buildFunction);
     assert(() {
       for (final param in _closureMirror.function.parameters) {
         if (!param.isNamed) {
           throw new AssertionFailure(
               'Static Tree factories doesn\'t support positional arguments.');
         }
       }
       return true;
     }());
     _propertyTypes = _lookupProperties(_closureMirror.function.parameters);
  }

  /// Creates a new instance of [VStaticTree] with [args] properties.
  VStaticTree _create([Map args]) {
    if (args == null) {
      return new VStaticTree(_buildFunction, null, null, null, null, null, null,
          null);
    }
    final HashMap<Symbol, dynamic> properties = new HashMap.from(args);
    final Object key = properties.remove(#key);
    final List<vdom.VNode> children = properties.remove(#children);
    final String id = properties.remove(#id);
    final Map<String, String> attributes = properties.remove(#attributes);
    final List<String> classes = properties.remove(#classes);
    final Map<String, String> styles = properties.remove(#styles);
    assert(() {
      for (final property in properties.keys) {
        if (!_propertyTypes.containsKey(property)) {
          throw new AssertionFailure(
              'Static Tree Node doesn\'t have a property $property.');
        }
      }
      return true;
    }());
    return new VStaticTree(_buildFunction, properties, key, children, id,
        attributes, classes, styles);
  }

  /// It is used to implement variadic arguments.
  VStaticTree noSuchMethod(Invocation invocation) {
    assert(invariant(invocation.positionalArguments.isEmpty, () =>
        'Static Tree factory invocation shouldn\'t have positional arguments.\n'
        'Positional arguments: ${invocation.positionalArguments}'));
    return _create(invocation.namedArguments);
  }

  /// Factory method invoked without any arguments.
  VStaticTree call() => _create();
}

/// [staticTreeFactory] function generates new factory for static tree vdom
/// nodes.
///
/// Static tree nodes are simple stateless nodes with lazy subtree generation.
/// Subtree is created when `render()` method is invoked and it never updates
/// later, even if the properties are changed. `update()` method just transfers
/// reference to root-level element from the previous node to the new one.
///
/// [staticTreeFactory] function should be treated as part of Liquid DSL,
/// and it should be invoked only in top-level declarations:
///
/// ```dart
/// final myNewElement = staticTreeFactory(({int counter}) =>
///     div()(counter.toString()));
/// ```
///
/// When the project is compiled with transformer, call to this function will be
/// transformed into an optimized Class with function to instantiate it.
Function staticTreeFactory(Function buildFunction) => new _VStaticTreeFactory(buildFunction);
