<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title> Liquid &middot; Liquid </title>

  <link rel="stylesheet" href="https://localvoid.github.io/liquid/css/poole.css">
  <link rel="stylesheet" href="https://localvoid.github.io/liquid/css/syntax.css">
  <link rel="stylesheet" href="https://localvoid.github.io/liquid/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <link href="https://localvoid.github.io/liquid/index.xml/" rel="alternate" type="application/rss+xml" title="Liquid" />
</head>

<body>

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>Liquid</h1>
      <p class="lead">
        A <a href="https://www.dartlang.org/">Dart</a> library to build User Interfaces.
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="/liquid/">Home</a> </li>
      
    </ul>

    <p>&copy; 2014. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
<div class="posts">

      
  <div class="post">
    <h1 class="post-title">
      <a href="https://localvoid.github.io/liquid/tutorials/todo-app/">
        Creating a Single Page Todo App with Liquid
      </a>
    </h1>

    <span class="post-date">Wed, Dec 3, 2014</span>
    

<p>Before starting this tutorial you should be familiar with the
<a href="https://www.dartlang.org">Dart language</a>.</p>

<p>In this tutorial I&rsquo;ll show how to build a simple Todo application with
Liquid library.</p>

<p>The primary goal of the Liquid library is to create general purpose
library for User Interfaces with reusable Components, and it does not
enforce you to make everything reactive, immutable, or stateless, you
are free to choose any way to structure your application.</p>

<h2 id="toc_0">Setup</h2>

<p>Make sure that you have
<a href="https://www.dartlang.org/tools/download.html">Dart SDK</a> installed and
running, the minimum version of the SDK is 1.6.</p>

<h3 id="toc_1">File Structure</h3>

<p>File structure of our application will conform to the
<a href="https://www.dartlang.org/tools/pub/package-layout.html">Pub Package Layout Conventions</a>.</p>

<pre><code>.
├── lib
│   ├── src
│   │   ├── models
│   │   │   ├── item.dart
│   │   │   └── item_list.dart
│   │   └── views
│   │       ├── app.dart
│   │       ├── header.dart
│   │       ├── item.dart
│   │       └── item_list.dart
│   ├── models.dart
│   └── views.dart
├── pubspec.yaml
└── web
    ├── index.dart
    └── index.html
</code></pre>

<h3 id="toc_2">Installing Packages</h3>

<p>Open <code>pubspec.yaml</code> file in the project root
directory and make sure that you have this dependencies:</p>

<pre><code>dependencies:
  browser: any
  liquid: any
</code></pre>

<p>Now run <code>$ pub get</code> command from the project&rsquo;s root directory to install all dependencies.</p>

<h2 id="toc_3">Data Model</h2>

<p>We will start writing our application by defining Data Model.</p>

<h3 id="toc_4">Item</h3>

<p>Item is an entry in our Todo List. It is quite simple, the only
important thing is that it should have unique key, so we can easily
find it. This key will be used in the Virtual DOM to find which Node
represents this item.</p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Item</span> {
  <span style="color: #008000; font-weight: bold">static</span> <span style="color: #B00040">int</span> _nextId <span style="color: #666666">=</span> <span style="color: #666666">0</span>; <span style="color: #408080; font-style: italic">// Used for Auto-Incremental Unique Keys</span>

  <span style="color: #008000; font-weight: bold">final</span> <span style="color: #B00040">int</span> id;
  <span style="color: #B00040">String</span> title;

  Item(<span style="color: #008000; font-weight: bold">this</span>.title) <span style="color: #666666">:</span> id <span style="color: #666666">=</span> _nextId<span style="color: #666666">++</span>;
}
</pre></div>

<h3 id="toc_5">ItemList</h3>

<p>ItemList will contain all entries and will be responsible for all
modifications. It also provides an event stream that emits events when
something is changed.</p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">ItemList</span> {
  <span style="color: #408080; font-style: italic">// Here we are creating Dart Streams to listen for</span>
  <span style="color: #408080; font-style: italic">// notifications when something is changed.</span>
  <span style="color: #408080; font-style: italic">//</span>
  <span style="color: #408080; font-style: italic">// If you are not familiar with Dart Stream,</span>
  <span style="color: #408080; font-style: italic">// you can read about them in this articles:</span>
  <span style="color: #408080; font-style: italic">//</span>
  <span style="color: #408080; font-style: italic">// https://www.dartlang.org/docs/tutorials/streams/</span>
  <span style="color: #408080; font-style: italic">// https://www.dartlang.org/articles/creating-streams/</span>

  StreamController _onChangesController <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> StreamController();
  Stream <span style="color: #008000; font-weight: bold">get</span> onChanges <span style="color: #666666">=&gt;</span> _onChangesController.stream;

  List<span style="color: #666666">&lt;</span>Item<span style="color: #666666">&gt;</span> items <span style="color: #666666">=</span> [];

  <span style="color: #408080; font-style: italic">// Actions:</span>

  <span style="color: #408080; font-style: italic">/// Create a new Todo Item</span>
  <span style="color: #B00040">void</span> createItem(<span style="color: #B00040">String</span> title) {
    <span style="color: #008000; font-weight: bold">if</span> (title.trim().isNotEmpty) {
      items.add(<span style="color: #008000; font-weight: bold">new</span> Item(title));
      _onChangesController.add(<span style="color: #008000; font-weight: bold">null</span>);
    }
  }

  <span style="color: #408080; font-style: italic">/// Update title property for Todo item</span>
  <span style="color: #B00040">void</span> updateItemTitle(<span style="color: #B00040">int</span> id, <span style="color: #B00040">String</span> newTitle) {
    <span style="color: #008000; font-weight: bold">if</span> (newTitle.trim().isEmpty) {
      items.removeWhere((i) <span style="color: #666666">=&gt;</span> i.id <span style="color: #666666">==</span> id);
    } <span style="color: #008000; font-weight: bold">else</span> {
      <span style="color: #008000; font-weight: bold">final</span> item <span style="color: #666666">=</span> items.firstWhere((i) <span style="color: #666666">=&gt;</span> i.id <span style="color: #666666">==</span> id);
      item.title <span style="color: #666666">=</span> newTitle;
    }
    _onChangesController.add(<span style="color: #008000; font-weight: bold">null</span>);
  }
}
</pre></div>

<h2 id="toc_6">Introduction to Virtual DOM</h2>

<p>If you ever worked with the DOM directly, you understand how hard is
to apply modification to the DOM when UI Component goes from one state
to another.</p>

<p>There are couple solutions for this problem, and the most popular is
the data-binding, that is used in libraries like Angular.</p>

<p>In the Liquid library we are using Virtual DOM with its diff/patch
algorithm to apply changes to the actual DOM. When state is changed,
we just rebuilding the Virtual DOM from the ground up and the
diff/patch takes care of all changes.</p>

<p><a href="http://www.youtube.com/watch?v=rI0GQc__0SM">Steven Luscher: Decomplexifying Code with React</a>
is a great explanation of complexity in UI Components.</p>

<h2 id="toc_7">Header Element</h2>

<p>Now we will create our first Virtual DOM Node for Header.</p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">final</span> vHeader <span style="color: #666666">=</span> v.staticTreeFactory(() <span style="color: #666666">=&gt;</span>
  v.h1(<span style="color: #A0A000">id:</span> <span style="color: #BA2121">&#39;header&#39;</span>)(<span style="color: #BA2121">&#39;TODO Application&#39;</span>));
</pre></div>

<p>We have a convention that all functions creating virtual dom nodes
should be prefixed with letter &lsquo;v&rsquo;.</p>

<p><code>staticTreeFactory(buildFunction)</code> returns factory function that will
generate virtual dom nodes.</p>

<p>All Nodes that accepts children are implementing function call
interface to specify children <code>Node()(children)</code>. Children argument
can be a simple String, single Node, or List of Nodes.</p>

<h2 id="toc_8">Introduction to Components</h2>

<p>Components is just an extension to html Elements, they have an
additional state, slightly more complex lifecycle and can render and
update itself using Virtual DOM.</p>

<h2 id="toc_9">Application Component</h2>

<p>It is time to build Component for our Application.</p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">App</span> <span style="color: #008000; font-weight: bold">extends</span> Component {
  <span style="border: 1px solid #FF0000">@</span>property models.ItemList data;

  v.VTextInput _input;
  <span style="color: #B00040">String</span> _title <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;&#39;</span>;

  <span style="color: #B00040">void</span> init() {
    data.onChanges.listen((_) {
      <span style="color: #408080; font-style: italic">// Invalidate Component when data is changed.</span>
      <span style="color: #408080; font-style: italic">//</span>
      <span style="color: #408080; font-style: italic">// When we invalidate Component, it means that it will</span>
      <span style="color: #408080; font-style: italic">// be updated on the next rendering frame.</span>
      <span style="color: #408080; font-style: italic">//</span>
      <span style="color: #408080; font-style: italic">// This way we can update DOM in batches, no need to</span>
      <span style="color: #408080; font-style: italic">// update it as soon as possible, especially when the</span>
      <span style="color: #408080; font-style: italic">// state can be changed mutiple times before browser</span>
      <span style="color: #408080; font-style: italic">// starts to render new frame.</span>
      invalidate();
    });

    <span style="color: #408080; font-style: italic">// Add Event Listeners using Event-Delegation.</span>
    element.onKeyPress.matches(<span style="color: #BA2121">&#39;input&#39;</span>).listen((e) {
      <span style="color: #008000; font-weight: bold">if</span> (e.keyCode <span style="color: #666666">==</span> KeyCode.ENTER) {
        <span style="color: #008000; font-weight: bold">if</span> (_input.value.isNotEmpty) {
          data.createItem(_input.value);
          _title <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;&#39;</span>;
        }
        e.stopPropagation();
        e.preventDefault();
      }
    });
  }

  build() {
    <span style="color: #408080; font-style: italic">// Here we are assigning VTextInput to [_input] property, so we can</span>
    <span style="color: #408080; font-style: italic">// reference it from the event listeners.</span>
    _input <span style="color: #666666">=</span> v.textInput(<span style="color: #A0A000">value:</span> _title);

    <span style="color: #008000; font-weight: bold">return</span> v.root()([
      vHeader(),
      vItemList(<span style="color: #A0A000">data:</span> data),
      _input
    ]);
  }
}
</pre></div>

<h2 id="toc_10">ItemList</h2>

<p>Item List will be a simple Virtual Dom Tree, no need to create a
stateful Component. But because it can change, we will use
<code>dynamicTreeFactory</code>. By default all named arguments have the same
behavior as <code>@property</code>. If you want to use immutable data structures,
just prepend <code>@immutable</code> annotation before named argument.</p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">final</span> vItemList <span style="color: #666666">=</span> v.dynamicTreeFactory(({data}) <span style="color: #666666">=&gt;</span>
  v.ul()(data.items.map((i) <span style="color: #666666">=&gt;</span>
    vItem(<span style="color: #A0A000">key:</span>    i.id,
          <span style="color: #A0A000">data:</span>   data,
          <span style="color: #A0A000">title:</span>  i.title,
          <span style="color: #A0A000">itemId:</span> i.id)).toList()));
</pre></div>

<h2 id="toc_11">Item Component</h2>

<p>Item will be implemented as a Component because it has internal
state. To create Components inside of VirtualDOM trees we need to
create a factory for this Component with
<code>componentFactory(Component)</code> function.</p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">final</span> vItem <span style="color: #666666">=</span> v.componentFactory(Item);
<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Item</span> <span style="color: #008000; font-weight: bold">extends</span> Component {
  <span style="border: 1px solid #FF0000">@</span>property models.ItemList data;
  <span style="border: 1px solid #FF0000">@</span>property <span style="color: #B00040">int</span> itemId;
  <span style="border: 1px solid #FF0000">@</span>property <span style="color: #B00040">String</span> title;

  <span style="color: #B00040">bool</span> _editing <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">false</span>;
  v.VTextInput _input;

  <span style="color: #B00040">void</span> create() { element <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> LIElement(); }

  <span style="color: #B00040">void</span> init() {
    element.onDoubleClick.matches(<span style="color: #BA2121">&#39;span&#39;</span>).listen((e) {
      _editing <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">true</span>;
      <span style="color: #408080; font-style: italic">// We can&#39;t focus _input Element right now, because it will be created</span>
      <span style="color: #408080; font-style: italic">// on the next frame. So we can use special [after] Future and wait</span>
      <span style="color: #408080; font-style: italic">// until next frame is rendered.</span>
      domScheduler.nextFrame.after().then((_) {
        <span style="color: #008000; font-weight: bold">if</span> (_editing) {
          _input.ref.focus();
        }
      });
      invalidate();
      e.stopPropagation();
      e.preventDefault();
    });

    element.onBlur.capture((e) {
      <span style="color: #008000; font-weight: bold">if</span> (_editing) {
        _editing <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">false</span>;
        data.updateItemTitle(itemId, _input.value);
      }
    });
  }

  build() {
    <span style="color: #008000; font-weight: bold">var</span> children;
    <span style="color: #008000; font-weight: bold">if</span> (_editing) {
      _input <span style="color: #666666">=</span> v.textInput(<span style="color: #A0A000">value:</span> title);
      children <span style="color: #666666">=</span> [_input];
    } <span style="color: #008000; font-weight: bold">else</span> {
      _input <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">null</span>;
      children <span style="color: #666666">=</span> [v.span()(title)];
    }

    <span style="color: #008000; font-weight: bold">return</span> v.root()(children);
  }
}
</pre></div>

<h2 id="toc_12">Inserting Components into the DOM</h2>

<p>Now we need to insert Application Component into the DOM, and we have
a special method for this <code>injectComponent(component, parentElement)</code>.</p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #B00040">void</span> main() {
  <span style="color: #008000; font-weight: bold">final</span> data <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> models.ItemList();
  injectComponent(<span style="color: #008000; font-weight: bold">new</span> views.App()..data <span style="color: #666666">=</span> data, document.body);
}
</pre></div>

<h2 id="toc_13">Source Code</h2>

<p>Source code is available at
<a href="https://github.com/localvoid/liquid-tutorial/">GitHub repository</a>.</p>

  </div>
  
</div>
</div>

  </body>
</html>
